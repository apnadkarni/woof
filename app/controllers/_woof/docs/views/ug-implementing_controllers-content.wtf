<h3>The <span class='wf_code'>ApplicationController</span> class</h3>

<p>The <span class='wf_code'>ApplicationController</span> class is
  defined to allow 
  the application programmer to add controller behaviours that are
  common to all application controllers without having the modify
  the <span class='wf_code'>Controller</span> class.</p> 


<p>To ensure future compatibility, application writers should not
  directly modify the <span class='wf_code'>Controller</span> class
  and should not directly inherit from it. Instead, all controllers
  should be defined to inherit from
  <span class="wf_code">ApplicationController</span>.
  Woof! itself does not add any new
  variables or methods in this class and promises not to modify it in
  future releases.
  The [my _chapter_link wag "wag"] stubs generator
  also generates stubs that follows this rule.</p>

<h3>Defining a controller class</h3>

<p>A minimal controller class definitions takes the following form:</p>

[my _code_sample {
oo::class create SampleController {
    superclass ApplicationController
    constructor args {
        # Very important to pass arguments to parent
        next {*}$args

        ...other initialization code...

    }

    method index {} {
        # The default method for the controller
        ...some code here...
    }
}

}]

<p>As discussed above, the class derives from
<span class="wf_code">ApplicationController</span>. The constructor
passes any specified arguments to its base class and then completes
initialization. It is important to call the base class constructor
before using any of the standard objects such as 
<span class="wf_code">request</span>,
<span class="wf_code">session</span> etc.
created by the base
<span class="wf_code">Controller</span> class.</p>

<p>The initialization steps may include
  application-specific code as well as some standard Woof!
  code such as setting up
  [my _chapter_link default_page_layout "default layout parameters"],
  [my _chapter_link using_stylesheets "stylesheets"] and so on.</p>

<h3>Controller classes and namespaces</h3>
<p>Controller classes are read into the
<span class="wf_code">::woof::app</span> namespace.
One important point to note is that the class name does not have
any namespace qualifiers. Even if the controller is defined to be in a
module, the class definition itself should generally not include the
namespace. Woof! will automatically instantiate the class into the
appropriate namespace based on the module name.</p>

<p>For example, assuming
the application URL root is <span class="wf_filename">/</span>, the
URL <span class="wf_filename">/mod1/mod2/sample/index</span>
corresponds to the <span class="wf_code">index</span> action in
controller <span class="wf_code">sample</span> in the module
<span class="wf_code">mod1::mod2</span>. The corresponding controller
implementation will be located under the Woof! directory in the file
<span class="wf_filename">app/controllers/mod1/mod2/sample_controller.tcl</span>.
The controller class as defined in the sample above (without any
namespace qualifiers), will be created as
<span class="wf_code">::woof::app::mod1::mod2::Sample</span>.</p>

<p>If at all namespace qualifiers are used, the
class name must be fully qualified and begin with 
<span class="wf_code">::woof::app</span> and include the module
namespaces if any. So the class definition above could have been
defined with the fully qualified name
<span class="wf_code">::woof::app::mod1::mod2::Sample</span>
but this is not recommended.</p>


<h3>Exposing controller methods as actions</h3>

<p>By default, all methods exported by a controller class are accessible
through a URL. Note this refers to the leaf controller class exports
and not any methods it inherits. Without an explicit
<span class="wf_code">export</span> statement, exports all methods
beginning with a lower case letters and no others. Alternatively, you
can use the Tcl class definition commands
<span class="wf_code">export</span> and
<span class="wf_code">unexport</span> to control what methods are
exported.</p>

<p>However, using Tcl's built-in mechanisms has the problem that
  un-exporting a method to prevent being accessed from a URL as an
  action also prevents it from being called by other objects. Woof!
  provides another mechanism for controlling exposure of methods as
  actions. A controller can define the method
  [my _manpage_link ::woof::Controller::_action_methods]. This should
  return a list of method names that may be accessed as actions. If
  this list is empty, the default behaviour above, where all exported
  methods are treated as actions, results.</p>

%# TBD <h3>Defining action methods</h3>
%# Retrieving parameters - params or normally


<h3>Defining a missing action handler</h3>

<p>When Woof! does not find a controller method with the name
  specified for the action, it invokes the method 
  <span class="wf_code">_missing_action</span> on the class. The
  default implementation of this in class
  <span class="wf_code">Controller</span> generates a <b>Page not
    found.</b> error page.</p>

<p>A controller may usefully override this method. For example, the
  controller for this user guide defines this method to simply
  return. The consequence is that Woof! will then simply pick up and
  display the appropriate page template for the documentation sections
  as specified by the action. No separate action method needs to be
  defined for each section.</p>

%# <h3>The use command</h3>



